import React, { SetStateAction } from 'react';

declare function componentWrapper<C extends React.ComponentType<any> | keyof React.JSX.IntrinsicElements, ExtraProps extends {} = {}>(displayName: string, render: React.ForwardRefRenderFunction<RefFromComponent<C>, React.ComponentPropsWithRef<C> & ExtraProps>): React.FC<React.ComponentPropsWithRef<C> & ExtraProps & {
    ref?: React.Ref<RefFromComponent<C>> | undefined;
}>;
type RefFromComponent<C extends React.ComponentType<any> | keyof React.JSX.IntrinsicElements> = NonNullable<RefFromComponentDistCond<React.ComponentPropsWithRef<C>["ref"]>>;
type RefFromComponentDistCond<A> = A extends React.RefObject<infer T> ? T : never;
declare function forwardRefIfNeeded<T, P = {}>(render: React.ForwardRefRenderFunction<T, P>): React.FC<P & {
    ref?: React.Ref<T>;
}>;
declare function getNodeText(node: React.ReactNode): string;
/**
 * Suspends the currently rendered component indefinitely. Will not unsuspend unless the component rerenders.
 *
 * You can use this to translate older query- or AsyncResult-based code to new the Suspense system, for example: `if (query.isLoading) suspend();`
 */
declare function suspend(): never;
declare function mapRef<T, R>(ref: ReadonlyRef<T>, mapper: (value: T) => R): ReadonlyRef<R>;
type ReadonlyRef<T> = {
    readonly current: T;
};
type RefState<T> = ReadonlyRef<T> & {
    set: (updater: SetStateAction<T>) => void;
};
/**
 * Like useState, but its value is immediately available on refState.current after being set.
 *
 * Like useRef, but setting the value will cause a rerender.
 *
 * Note that useRefState returns a new object every time a rerender happens due to a value change, which is intentional
 * as it allows you to specify it in a dependency array like this:
 *
 * ```tsx
 * useEffect(() => {
 *   // do something with refState.current
 * }, [refState]);  // instead of refState.current
 * ```
 *
 * If you don't want this, you can wrap the result in a useMemo call.
 */
declare function useRefState<T>(initialValue: T): RefState<T>;
declare function mapRefState<T, R>(refState: RefState<T>, mapper: (value: T) => R, reverseMapper: (oldT: T, newR: R) => T): RefState<R>;
declare class NoSuspenseBoundaryError extends Error {
    digest: string;
    reason: string;
    constructor(options: {
        caller?: string;
    });
}
/**
 * Use this in a component or a hook to disable SSR. Should be wrapped in a Suspense boundary, or it will throw an error.
 */
declare function suspendIfSsr(caller?: string): void;

export { NoSuspenseBoundaryError, type ReadonlyRef, type RefState, componentWrapper, forwardRefIfNeeded, getNodeText, mapRef, mapRefState, suspend, suspendIfSsr, useRefState };
