import { Join } from './strings.mjs';

type IsAny<T> = 0 extends (1 & T) ? true : false;
type IsNever<T> = [T] extends [never] ? true : false;
type IsNullish<T> = [T] extends [null | undefined] ? true : false;
type IsUnion<T, U = T> = IsNever<T> extends true ? false : IsAny<T> extends true ? false : T extends U ? ([U] extends [T] ? false : true) : never;
type NullishCoalesce<T, U> = T extends null | undefined ? U : T;
type LastUnionElement<U> = UnionToIntersection<U extends any ? (x: U) => 0 : never> extends (x: infer L) => 0 ? L & U : never;
type primitive = string | number | boolean | bigint | symbol | null | undefined;
/**
 * Makes a type prettier by recursively expanding all object types. For example, `Omit<{ a: 1 }, "a">` becomes just `{}`.
 */
type Expand<T> = T extends (...args: infer A) => infer R ? ((...args: A) => R) extends T ? (...args: Expand<A>) => Expand<R> : ((...args: Expand<A>) => Expand<R>) & {
    [K in keyof T]: Expand<T[K]>;
} : T extends object ? T extends primitive ? T : T extends infer O ? {
    [K in keyof O]: Expand<O[K]>;
} : never : T;
/**
 * Removes all optional undefined/never keys from an object.
 */
type DeepRemoveOptionalUndefined<T> = T extends object ? {
    [K in keyof T]: DeepRemoveOptionalUndefined<T[K]>;
} : T;
type UnionToIntersection<U> = (U extends any ? (x: U) => void : never) extends ((x: infer I) => void) ? I : never;
type _UnionToTupleInner<U, R extends any[], Last> = UnionToTuple<Exclude<U, Last>, [...R, Last]>;
type UnionToTuple<U, R extends any[] = []> = [U] extends [never] ? R : _UnionToTupleInner<U, R, LastUnionElement<U>>;
type CollapseObjectUnion<T extends object> = {
    [K in AllUnionKeys<T>]?: T extends Record<K, infer V> ? V : never;
};
type IntersectAll<T extends any[]> = UnionToIntersection<T[number]>;
type OptionalKeys<T> = {
    [K in keyof T]: {} extends Pick<T, K> ? K : never;
}[keyof T];
type RequiredKeys<T> = {
    [K in keyof T]: {} extends Pick<T, K> ? never : K;
}[keyof T];
/**
 * Returns a type whose keys are the intersection of the keys of T and U, deeply.
 */
type KeyIntersect<T, U> = {
    [K in keyof T & keyof U]?: T[K] & U[K];
} | {
    [K in RequiredKeys<T> & keyof U]: T[K] & U[K];
} | {
    [K in RequiredKeys<U> & keyof T]: U[K] & T[K];
};
/**
 * Returns ALL keys of all union elements.
 */
type AllUnionKeys<T extends object> = T extends T ? keyof T : never;
type SubtractType<T, U> = T extends object ? {
    [K in keyof T]: K extends keyof U ? SubtractType<T[K], U[K]> : T[K];
} : (T extends U ? never : T);
type XOR<T extends readonly any[]> = T extends readonly [infer A, infer B, ...infer Rest] ? Rest extends [] ? (A & {
    [K in keyof B]?: never;
}) | (B & {
    [K in keyof A]?: never;
}) : XOR<[(A & {
    [K in keyof B]?: never;
}) | (B & {
    [K in keyof A]?: never;
}), ...Rest]> : T[0];
type _AntiIntersectInner<T, U> = T extends object ? (Omit<U, keyof T> & {
    [K in keyof Pick<U, {
        [K in keyof T & keyof U]: U[K] extends T[K] ? (T[K] extends U[K] ? never : K) : never;
    }[keyof T & keyof U]>]: PseudoAntiIntersect<T[K], U[K]>;
} & {
    [K in keyof Pick<U, keyof T & keyof U>]?: PseudoAntiIntersect<T[K], U[K]>;
}) : U;
/**
 * Returns a type R such that T & R = U.
 */
type AntiIntersect<T, U> = U extends T ? _AntiIntersectInner<T, U> : "Cannot anti-intersect a type with a type that is not a subtype of it";
type PseudoAntiIntersect<T, U> = _AntiIntersectInner<T, T & U>;
/**
 * A variation of TypeScript's conditionals with slightly different semantics. It is the perfect type for cases where:
 *
 * - If all possible values are contained in `Extends`, then it will be mapped to `Then`.
 * - If all possible values are not contained in `Extends`, then it will be mapped to `Otherwise`.
 * - If some possible values are contained in `Extends` and some are not, then it will be mapped to `Then | Otherwise`.
 *
 * This is different from TypeScript's built-in conditional types (`Value extends Extends ? Then : Otherwise`), which
 * returns `Otherwise` for the third case (causing unsoundness in many real-world cases).
 */
type IfAndOnlyIf<Value, Extends, Then, Otherwise> = (Value extends Extends ? never : Otherwise) | (Value & Extends extends never ? never : Then);
/**
 * Can be used to prettify a type in the IDE; for example, some complicated intersected types can be flattened into a single type.
 */
type PrettifyType<T> = T extends object ? {
    [K in keyof T]: T[K];
} & {} : T;
type _ToStringAndJoin<T extends any[], Separator extends string> = T extends [infer U, ...infer Rest extends any[]] ? `${TypeToString<U>}${Rest extends [any, ...any[]] ? `${Separator}${_ToStringAndJoin<Rest, Separator>}` : ""}` : "<error-joining-tuple-elements>";
type _TypeToStringInner<T> = IsAny<T> extends true ? "any" : IsNever<T> extends true ? "never" : IsUnion<T> extends true ? _ToStringAndJoin<UnionToTuple<T>, " | "> : [T] extends [number] ? (number extends T ? "number" : `${T}`) : [T] extends [boolean] ? `${T}` : [T] extends [undefined] ? "undefined" : [T] extends [null] ? "null" : [T] extends [string] ? (string extends T ? "string" : `'${T}'`) : [T] extends [[]] ? "[]" : [T] extends [[any, ...any[]]] ? `[${_ToStringAndJoin<T, ", ">}]` : [T] extends [(infer E)[]] ? `${TypeToString<E>}[]` : [T] extends [Function] ? "function" : [T] extends [symbol] ? `symbol(${T['description']})` : [T] extends [object] ? `{ ${Join<UnionToTuple<{
    [K in keyof T]: `${TypeToString<K>}: ${TypeToString<T[K]>}`;
}[keyof T]>, ", ">} }` : "<unknown-type>";
type TypeToString<T> = _TypeToStringInner<T> extends `${infer S}` ? S : never;
/**
 * Can be used to create assertions on types. For example, if passed any T other than `true`, the following will
 * show a type error:
 *
 * ```ts
 * typeAssert<T>()();  // the second pair of braces is important!
 * ```
 */
declare function typeAssert<T>(): (IsAny<T> extends true ? TypeAssertionError<`Type assertion failed. Expected true, but got any.`> : IsNever<T> extends true ? TypeAssertionError<`Type assertion failed. Expected true, but got never.`> : T extends true ? (() => undefined) : TypeAssertionError<`Type assertion failed. Expected true, but got: ${TypeToString<T>}`>);
type TypeAssertionError<T> = [T] & /* this promise makes sure that if we accidentally forget the second pair of braces, eslint will complain (if we have no-floating-promises enabled) */ Promise<any>;
/**
 * Functionally equivalent to `typeAssert<T extends S ? true : false>()()`, but with better error messages.
 */
declare function typeAssertExtends<T, S>(): ([
    T
] extends [S] ? (() => undefined) : TypeAssertionError<`Type assertion failed. Expected ${TypeToString<T>} to extend ${TypeToString<S>}`>);
declare function typeAssertIs<T, U>(): (IsAny<T> extends true ? (IsAny<U> extends true ? (() => undefined) : TypeAssertionError<`Type assertion failed. Expected ${TypeToString<T>} to be ${TypeToString<U>}`>) : IsAny<U> extends true ? TypeAssertionError<`Type assertion failed. Expected ${TypeToString<T>} to be ${TypeToString<U>}`> : [T] extends [U] ? ([U] extends [T] ? (() => undefined) : TypeAssertionError<`Type assertion failed. Expected ${TypeToString<T>} to be ${TypeToString<U>}`>) : TypeAssertionError<`Type assertion failed. Expected ${TypeToString<T>} to be ${TypeToString<U>}`>);

export { type AllUnionKeys, type AntiIntersect, type CollapseObjectUnion, type DeepRemoveOptionalUndefined, type Expand, type IfAndOnlyIf, type IntersectAll, type IsAny, type IsNever, type IsNullish, type IsUnion, type KeyIntersect, type LastUnionElement, type NullishCoalesce, type OptionalKeys, type PrettifyType, type PseudoAntiIntersect, type RequiredKeys, type SubtractType, type TypeToString, type UnionToIntersection, type UnionToTuple, type XOR, typeAssert, typeAssertExtends, typeAssertIs };
