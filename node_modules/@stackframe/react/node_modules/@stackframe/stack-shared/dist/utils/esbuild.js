"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/utils/esbuild.tsx
var esbuild_exports = {};
__export(esbuild_exports, {
  bundleJavaScript: () => bundleJavaScript,
  initializeEsbuild: () => initializeEsbuild
});
module.exports = __toCommonJS(esbuild_exports);
var esbuild = __toESM(require("esbuild-wasm/lib/browser.js"));
var import_path = require("path");
var import_env = require("./env.js");
var import_errors = require("./errors.js");
var import_results = require("./results.js");
var import_telemetry = require("./telemetry.js");
var esbuildWasmUrl = `https://unpkg.com/esbuild-wasm@${esbuild.version}/esbuild.wasm`;
var esbuildInitializePromise = null;
globalThis.self ??= globalThis;
function initializeEsbuild() {
  if (!esbuildInitializePromise) {
    esbuildInitializePromise = (0, import_telemetry.withTraceSpan)("initializeEsbuild", async () => {
      if ((0, import_env.isBrowserLike)()) {
        await esbuild.initialize({
          wasmURL: esbuildWasmUrl
        });
      } else {
        const esbuildWasmResponse = await fetch(esbuildWasmUrl);
        if (!esbuildWasmResponse.ok) {
          throw new import_errors.StackAssertionError(`Failed to fetch esbuild.wasm: ${esbuildWasmResponse.status} ${esbuildWasmResponse.statusText}: ${await esbuildWasmResponse.text()}`);
        }
        const esbuildWasm = await esbuildWasmResponse.arrayBuffer();
        const esbuildWasmArray = new Uint8Array(esbuildWasm);
        if (esbuildWasmArray[0] !== 0 || esbuildWasmArray[1] !== 97 || esbuildWasmArray[2] !== 115 || esbuildWasmArray[3] !== 109) {
          throw new import_errors.StackAssertionError(`Invalid esbuild.wasm file: ${new TextDecoder().decode(esbuildWasmArray)}`);
        }
        const esbuildWasmModule = new WebAssembly.Module(esbuildWasm);
        await esbuild.initialize({
          wasmModule: esbuildWasmModule,
          worker: false
        });
      }
    })();
  }
  return esbuildInitializePromise;
}
async function bundleJavaScript(sourceFiles, options = {}) {
  await initializeEsbuild();
  const sourceFilesMap = new Map(Object.entries(sourceFiles));
  const externalPackagesMap = new Map(Object.entries(options.externalPackages ?? {}));
  const keepAsImports = options.keepAsImports ?? [];
  const httpImportCache = /* @__PURE__ */ new Map();
  const extToLoader = /* @__PURE__ */ new Map([
    ["tsx", "tsx"],
    ["ts", "ts"],
    ["js", "js"],
    ["jsx", "jsx"],
    ["json", "json"],
    ["css", "css"]
  ]);
  let result;
  try {
    result = await (0, import_telemetry.traceSpan)("bundleJavaScript", async () => await esbuild.build({
      entryPoints: ["/entry.js"],
      bundle: true,
      write: false,
      format: options.format ?? "iife",
      platform: "browser",
      target: "es2015",
      jsx: "automatic",
      sourcemap: options.sourcemap ?? "inline",
      external: keepAsImports,
      plugins: [
        ...options.allowHttpImports ? [{
          name: "esm-sh-only",
          setup(build2) {
            build2.onResolve({ filter: /.*/ }, (args) => {
              const isHttp = args.path.startsWith("http://") || args.path.startsWith("https://");
              const fromEsmNs = args.namespace === "esm-sh";
              if (!isHttp && !fromEsmNs) return null;
              const url = new URL(args.path, fromEsmNs ? args.importer : void 0);
              if (url.protocol !== "https:" || url.host !== "esm.sh") {
                throw new Error(`Blocked non-esm.sh URL import: ${url.href}`);
              }
              return { path: url.href, namespace: "esm-sh" };
            });
            build2.onLoad({ filter: /.*/, namespace: "esm-sh" }, async (args) => {
              if (httpImportCache.has(args.path)) return httpImportCache.get(args.path);
              const res = await fetch(args.path, { redirect: "follow" });
              if (!res.ok) throw new Error(`Fetch ${res.status} ${res.statusText} for ${args.path}`);
              const finalUrl = new URL(res.url);
              if (finalUrl.host !== "esm.sh") {
                throw new Error(`Redirect escaped esm.sh: ${finalUrl.href}`);
              }
              const ct = (res.headers.get("content-type") || "").toLowerCase();
              let loader = ct.includes("css") ? "css" : ct.includes("json") ? "json" : ct.includes("typescript") ? "ts" : ct.includes("jsx") ? "jsx" : ct.includes("tsx") ? "tsx" : "js";
              const p = finalUrl.pathname;
              if (p.endsWith(".css")) loader = "css";
              else if (p.endsWith(".json")) loader = "json";
              else if (p.endsWith(".ts")) loader = "ts";
              else if (p.endsWith(".tsx")) loader = "tsx";
              else if (p.endsWith(".jsx")) loader = "jsx";
              const contents = await res.text();
              const result2 = {
                contents,
                loader,
                // Ensures relative imports inside that module resolve against the fileâ€™s URL
                resolveDir: new URL(".", finalUrl.href).toString(),
                watchFiles: [finalUrl.href]
              };
              httpImportCache.set(args.path, result2);
              return result2;
            });
          }
        }] : [],
        {
          name: "replace-packages-with-globals",
          setup(build2) {
            build2.onResolve({ filter: /.*/ }, (args) => {
              if (keepAsImports.includes(args.path)) {
                return void 0;
              }
              if (externalPackagesMap.has(args.path)) {
                return { path: args.path, namespace: "package-shim" };
              }
              return void 0;
            });
            build2.onLoad({ filter: /.*/, namespace: "package-shim" }, (args) => {
              const contents = externalPackagesMap.get(args.path);
              if (contents == null) throw new import_errors.StackAssertionError(`esbuild requested file ${args.path} that is not in the virtual file system`);
              return { contents, loader: "ts" };
            });
          }
        },
        {
          name: "virtual-fs",
          setup(build2) {
            build2.onResolve({ filter: /.*/ }, (args) => {
              const absolutePath = (0, import_path.join)("/", args.path);
              if (sourceFilesMap.has(absolutePath)) {
                return { path: absolutePath, namespace: "virtual" };
              }
              return void 0;
            });
            build2.onLoad({ filter: /.*/, namespace: "virtual" }, (args) => {
              const contents = sourceFilesMap.get(args.path);
              if (contents == null) throw new import_errors.StackAssertionError(`esbuild requested file ${args.path} that is not in the virtual file system`);
              const ext = args.path.split(".").pop() ?? "";
              const loader = extToLoader.get(ext) ?? (0, import_errors.throwErr)(`esbuild requested file ${args.path} with unknown extension ${ext}`);
              return { contents, loader };
            });
          }
        }
      ]
    }));
  } catch (e) {
    if (e instanceof Error && e.message.startsWith("Build failed with ")) {
      return import_results.Result.error(e.message);
    }
    throw e;
  }
  if (result.errors.length > 0) {
    return import_results.Result.error(result.errors.map((e) => e.text).join("\n"));
  }
  if (result.outputFiles.length > 0) {
    return import_results.Result.ok(result.outputFiles[0].text);
  }
  return (0, import_errors.throwErr)("No output generated??");
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  bundleJavaScript,
  initializeEsbuild
});
//# sourceMappingURL=esbuild.js.map