// src/utils/esbuild.tsx
import * as esbuild from "esbuild-wasm/lib/browser.js";
import { join } from "path";
import { isBrowserLike } from "./env.js";
import { StackAssertionError, throwErr } from "./errors.js";
import { Result } from "./results.js";
import { traceSpan, withTraceSpan } from "./telemetry.js";
var esbuildWasmUrl = `https://unpkg.com/esbuild-wasm@${esbuild.version}/esbuild.wasm`;
var esbuildInitializePromise = null;
globalThis.self ??= globalThis;
function initializeEsbuild() {
  if (!esbuildInitializePromise) {
    esbuildInitializePromise = withTraceSpan("initializeEsbuild", async () => {
      if (isBrowserLike()) {
        await esbuild.initialize({
          wasmURL: esbuildWasmUrl
        });
      } else {
        const esbuildWasmResponse = await fetch(esbuildWasmUrl);
        if (!esbuildWasmResponse.ok) {
          throw new StackAssertionError(`Failed to fetch esbuild.wasm: ${esbuildWasmResponse.status} ${esbuildWasmResponse.statusText}: ${await esbuildWasmResponse.text()}`);
        }
        const esbuildWasm = await esbuildWasmResponse.arrayBuffer();
        const esbuildWasmArray = new Uint8Array(esbuildWasm);
        if (esbuildWasmArray[0] !== 0 || esbuildWasmArray[1] !== 97 || esbuildWasmArray[2] !== 115 || esbuildWasmArray[3] !== 109) {
          throw new StackAssertionError(`Invalid esbuild.wasm file: ${new TextDecoder().decode(esbuildWasmArray)}`);
        }
        const esbuildWasmModule = new WebAssembly.Module(esbuildWasm);
        await esbuild.initialize({
          wasmModule: esbuildWasmModule,
          worker: false
        });
      }
    })();
  }
  return esbuildInitializePromise;
}
async function bundleJavaScript(sourceFiles, options = {}) {
  await initializeEsbuild();
  const sourceFilesMap = new Map(Object.entries(sourceFiles));
  const externalPackagesMap = new Map(Object.entries(options.externalPackages ?? {}));
  const keepAsImports = options.keepAsImports ?? [];
  const httpImportCache = /* @__PURE__ */ new Map();
  const extToLoader = /* @__PURE__ */ new Map([
    ["tsx", "tsx"],
    ["ts", "ts"],
    ["js", "js"],
    ["jsx", "jsx"],
    ["json", "json"],
    ["css", "css"]
  ]);
  let result;
  try {
    result = await traceSpan("bundleJavaScript", async () => await esbuild.build({
      entryPoints: ["/entry.js"],
      bundle: true,
      write: false,
      format: options.format ?? "iife",
      platform: "browser",
      target: "es2015",
      jsx: "automatic",
      sourcemap: options.sourcemap ?? "inline",
      external: keepAsImports,
      plugins: [
        ...options.allowHttpImports ? [{
          name: "esm-sh-only",
          setup(build2) {
            build2.onResolve({ filter: /.*/ }, (args) => {
              const isHttp = args.path.startsWith("http://") || args.path.startsWith("https://");
              const fromEsmNs = args.namespace === "esm-sh";
              if (!isHttp && !fromEsmNs) return null;
              const url = new URL(args.path, fromEsmNs ? args.importer : void 0);
              if (url.protocol !== "https:" || url.host !== "esm.sh") {
                throw new Error(`Blocked non-esm.sh URL import: ${url.href}`);
              }
              return { path: url.href, namespace: "esm-sh" };
            });
            build2.onLoad({ filter: /.*/, namespace: "esm-sh" }, async (args) => {
              if (httpImportCache.has(args.path)) return httpImportCache.get(args.path);
              const res = await fetch(args.path, { redirect: "follow" });
              if (!res.ok) throw new Error(`Fetch ${res.status} ${res.statusText} for ${args.path}`);
              const finalUrl = new URL(res.url);
              if (finalUrl.host !== "esm.sh") {
                throw new Error(`Redirect escaped esm.sh: ${finalUrl.href}`);
              }
              const ct = (res.headers.get("content-type") || "").toLowerCase();
              let loader = ct.includes("css") ? "css" : ct.includes("json") ? "json" : ct.includes("typescript") ? "ts" : ct.includes("jsx") ? "jsx" : ct.includes("tsx") ? "tsx" : "js";
              const p = finalUrl.pathname;
              if (p.endsWith(".css")) loader = "css";
              else if (p.endsWith(".json")) loader = "json";
              else if (p.endsWith(".ts")) loader = "ts";
              else if (p.endsWith(".tsx")) loader = "tsx";
              else if (p.endsWith(".jsx")) loader = "jsx";
              const contents = await res.text();
              const result2 = {
                contents,
                loader,
                // Ensures relative imports inside that module resolve against the fileâ€™s URL
                resolveDir: new URL(".", finalUrl.href).toString(),
                watchFiles: [finalUrl.href]
              };
              httpImportCache.set(args.path, result2);
              return result2;
            });
          }
        }] : [],
        {
          name: "replace-packages-with-globals",
          setup(build2) {
            build2.onResolve({ filter: /.*/ }, (args) => {
              if (keepAsImports.includes(args.path)) {
                return void 0;
              }
              if (externalPackagesMap.has(args.path)) {
                return { path: args.path, namespace: "package-shim" };
              }
              return void 0;
            });
            build2.onLoad({ filter: /.*/, namespace: "package-shim" }, (args) => {
              const contents = externalPackagesMap.get(args.path);
              if (contents == null) throw new StackAssertionError(`esbuild requested file ${args.path} that is not in the virtual file system`);
              return { contents, loader: "ts" };
            });
          }
        },
        {
          name: "virtual-fs",
          setup(build2) {
            build2.onResolve({ filter: /.*/ }, (args) => {
              const absolutePath = join("/", args.path);
              if (sourceFilesMap.has(absolutePath)) {
                return { path: absolutePath, namespace: "virtual" };
              }
              return void 0;
            });
            build2.onLoad({ filter: /.*/, namespace: "virtual" }, (args) => {
              const contents = sourceFilesMap.get(args.path);
              if (contents == null) throw new StackAssertionError(`esbuild requested file ${args.path} that is not in the virtual file system`);
              const ext = args.path.split(".").pop() ?? "";
              const loader = extToLoader.get(ext) ?? throwErr(`esbuild requested file ${args.path} with unknown extension ${ext}`);
              return { contents, loader };
            });
          }
        }
      ]
    }));
  } catch (e) {
    if (e instanceof Error && e.message.startsWith("Build failed with ")) {
      return Result.error(e.message);
    }
    throw e;
  }
  if (result.errors.length > 0) {
    return Result.error(result.errors.map((e) => e.text).join("\n"));
  }
  if (result.outputFiles.length > 0) {
    return Result.ok(result.outputFiles[0].text);
  }
  return throwErr("No output generated??");
}
export {
  bundleJavaScript,
  initializeEsbuild
};
//# sourceMappingURL=esbuild.js.map