// src/config/schema.ts
import * as yup from "yup";
import { DEFAULT_EMAIL_TEMPLATES, DEFAULT_EMAIL_THEMES, DEFAULT_EMAIL_THEME_ID } from "../helpers/emails.js";
import * as schemaFields from "../schema-fields.js";
import { offerSchema, userSpecifiedIdSchema, yupBoolean, yupDate, yupMixed, yupNever, yupNumber, yupObject, yupRecord, yupString, yupTuple, yupUnion } from "../schema-fields.js";
import { isShallowEqual } from "../utils/arrays.js";
import { SUPPORTED_CURRENCIES } from "../utils/currency-constants.js";
import { StackAssertionError } from "../utils/errors.js";
import { allProviders } from "../utils/oauth.js";
import { deleteKey, filterUndefined, get, has, isObjectLike, mapValues, set, typedAssign, typedEntries, typedFromEntries } from "../utils/objects.js";
import { Result } from "../utils/results.js";
import { typeAssert, typeAssertExtends, typeAssertIs } from "../utils/types.js";
import { NormalizationError, assertNormalized, getInvalidConfigReason, normalize } from "./format.js";
var configLevels = ["project", "branch", "environment", "organization"];
var permissionRegex = /^\$?[a-z0-9_:]+$/;
var customPermissionRegex = /^[a-z0-9_:]+$/;
function canNoLongerBeOverridden(schema, keys) {
  const notOmitted = schema.concat(yupObject(
    Object.fromEntries(keys.map((key) => [key, schema.getNested(key).meta({ stackConfigCanNoLongerBeOverridden: true })]))
  ));
  return notOmitted;
}
var projectConfigSchema = yupObject({
  sourceOfTruth: yupUnion(
    yupObject({
      type: yupString().oneOf(["hosted"]).defined()
    }),
    yupObject({
      type: yupString().oneOf(["neon"]).defined(),
      connectionStrings: yupRecord(
        userSpecifiedIdSchema("connectionStringId").defined(),
        yupString().defined()
      ).defined()
    }),
    yupObject({
      type: yupString().oneOf(["postgres"]).defined(),
      connectionString: yupString().defined()
    })
  )
});
var branchRbacDefaultPermissions = yupRecord(
  yupString().matches(permissionRegex),
  yupBoolean().isTrue().optional()
);
var branchRbacSchema = yupObject({
  permissions: yupRecord(
    yupString().matches(customPermissionRegex),
    yupObject({
      description: yupString().optional(),
      scope: yupString().oneOf(["team", "project"]).optional(),
      containedPermissionIds: yupRecord(
        yupString().matches(permissionRegex),
        yupBoolean().isTrue().optional()
      ).optional()
    }).optional()
  ),
  defaultPermissions: yupObject({
    teamCreator: branchRbacDefaultPermissions,
    teamMember: branchRbacDefaultPermissions,
    signUp: branchRbacDefaultPermissions
  })
});
var branchApiKeysSchema = yupObject({
  enabled: yupObject({
    team: yupBoolean(),
    user: yupBoolean()
  })
});
var branchAuthSchema = yupObject({
  allowSignUp: yupBoolean(),
  password: yupObject({
    allowSignIn: yupBoolean()
  }),
  otp: yupObject({
    allowSignIn: yupBoolean()
  }),
  passkey: yupObject({
    allowSignIn: yupBoolean()
  }),
  oauth: yupObject({
    accountMergeStrategy: yupString().oneOf(["link_method", "raise_error", "allow_duplicates"]).optional(),
    providers: yupRecord(
      yupString().matches(permissionRegex),
      yupObject({
        type: yupString().oneOf(allProviders).optional(),
        allowSignIn: yupBoolean(),
        allowConnectedAccounts: yupBoolean()
      })
    )
  })
});
var branchPaymentsSchema = yupObject({
  autoPay: yupObject({
    interval: schemaFields.dayIntervalSchema
  }).optional(),
  groups: yupRecord(
    userSpecifiedIdSchema("groupId"),
    yupObject({
      displayName: yupString().optional()
    })
  ).meta({ openapiField: { description: "The groups that offers can be in. All offers in a group (besides add-ons) are mutually exclusive.", exampleValue: { "group-id": { displayName: "My Group" } } } }),
  offers: yupRecord(
    userSpecifiedIdSchema("offerId"),
    offerSchema
  ),
  items: yupRecord(
    userSpecifiedIdSchema("itemId"),
    yupObject({
      displayName: yupString().optional(),
      customerType: schemaFields.customerTypeSchema
    })
  )
});
var branchDomain = yupObject({
  allowLocalhost: yupBoolean()
});
var branchWorkflowsSchema = yupObject({
  availableWorkflows: yupRecord(
    userSpecifiedIdSchema("workflowId"),
    yupObject({
      displayName: yupString(),
      tsSource: yupString(),
      enabled: yupBoolean()
    })
  )
});
var branchConfigSchema = canNoLongerBeOverridden(projectConfigSchema, ["sourceOfTruth"]).concat(yupObject({
  rbac: branchRbacSchema,
  teams: yupObject({
    createPersonalTeamOnSignUp: yupBoolean(),
    allowClientTeamCreation: yupBoolean()
  }),
  users: yupObject({
    allowClientUserDeletion: yupBoolean()
  }),
  apiKeys: branchApiKeysSchema,
  domains: branchDomain,
  auth: branchAuthSchema,
  emails: yupObject({
    selectedThemeId: schemaFields.emailThemeSchema,
    themes: schemaFields.emailThemeListSchema,
    templates: schemaFields.emailTemplateListSchema
  }),
  payments: branchPaymentsSchema,
  dataVault: yupObject({
    stores: yupRecord(
      userSpecifiedIdSchema("storeId"),
      yupObject({
        displayName: yupString()
      })
    )
  }),
  workflows: branchWorkflowsSchema
}));
var environmentConfigSchema = branchConfigSchema.concat(yupObject({
  auth: branchConfigSchema.getNested("auth").concat(yupObject({
    oauth: branchConfigSchema.getNested("auth").getNested("oauth").concat(yupObject({
      providers: yupRecord(
        yupString().matches(permissionRegex),
        yupObject({
          type: yupString().oneOf(allProviders).optional(),
          isShared: yupBoolean(),
          clientId: schemaFields.oauthClientIdSchema.optional(),
          clientSecret: schemaFields.oauthClientSecretSchema.optional(),
          facebookConfigId: schemaFields.oauthFacebookConfigIdSchema.optional(),
          microsoftTenantId: schemaFields.oauthMicrosoftTenantIdSchema.optional(),
          allowSignIn: yupBoolean().optional(),
          allowConnectedAccounts: yupBoolean().optional()
        })
      )
    }))
  })),
  emails: branchConfigSchema.getNested("emails").concat(yupObject({
    server: yupObject({
      isShared: yupBoolean(),
      provider: yupString().oneOf(["resend", "smtp"]).optional(),
      host: schemaFields.emailHostSchema.optional().nonEmpty(),
      port: schemaFields.emailPortSchema.optional(),
      username: schemaFields.emailUsernameSchema.optional().nonEmpty(),
      password: schemaFields.emailPasswordSchema.optional().nonEmpty(),
      senderName: schemaFields.emailSenderNameSchema.optional().nonEmpty(),
      senderEmail: schemaFields.emailSenderEmailSchema.optional().nonEmpty()
    })
  })),
  domains: branchConfigSchema.getNested("domains").concat(yupObject({
    trustedDomains: yupRecord(
      userSpecifiedIdSchema("trustedDomainId"),
      yupObject({
        baseUrl: schemaFields.wildcardUrlSchema.max(300),
        handlerPath: schemaFields.handlerPathSchema.max(300)
      })
    )
  }))
}));
var organizationConfigSchema = environmentConfigSchema.concat(yupObject({}));
function migrateConfigOverride(type, oldUnmigratedConfigOverride) {
  const isBranchOrHigher = ["branch", "environment", "organization"].includes(type);
  const isEnvironmentOrHigher = ["environment", "organization"].includes(type);
  let res = oldUnmigratedConfigOverride;
  if (isBranchOrHigher) {
    res = renameProperty(res, "emails.theme", "emails.selectedThemeId");
  }
  if (isEnvironmentOrHigher) {
    res = mapProperty(res, (p) => p.join(".") === "domains.trustedDomains", (value) => {
      if (Array.isArray(value)) {
        return typedFromEntries(value.map((v, i) => [`${i}`, v]));
      }
      return value;
    });
  }
  if (isBranchOrHigher) {
    res = removeProperty(res, (p) => p.join(".") === "emails.themeList");
    res = removeProperty(res, (p) => p.join(".") === "emails.templateList");
  }
  if (type === "environment") {
    res = removeProperty(res, (p) => p.join(".") === "sourceOfTruth");
  }
  if (type === "environment") {
    res = removeProperty(res, (p) => p.join(".") === "payments.stripeAccountId");
    res = removeProperty(res, (p) => p.join(".") === "payments.stripeAccountSetupComplete");
  }
  if (isBranchOrHigher) {
    res = removeProperty(res, (p) => p.length === 4 && p[0] === "payments" && p[1] === "items" && p[3] === "default");
  }
  return res;
}
function removeProperty(obj, pathCond) {
  return mapProperty(obj, pathCond, () => void 0);
}
function mapProperty(obj, pathCond, mapper) {
  const res = Array.isArray(obj) ? [] : {};
  for (const [key, value] of typedEntries(obj)) {
    const path = key.split(".");
    if (pathCond(path)) {
      const newValue = mapper(value);
      if (newValue !== void 0) {
        set(res, key, newValue);
      } else {
      }
    } else if (isObjectLike(value)) {
      set(res, key, mapProperty(value, (p) => pathCond([...path, ...p]), mapper));
    } else {
      set(res, key, value);
    }
  }
  return res;
}
function renameProperty(obj, oldPath, newPath) {
  const oldKeyParts = oldPath.split(".");
  const newKeyParts = newPath.split(".");
  if (!isShallowEqual(oldKeyParts.slice(0, -1), newKeyParts.slice(0, -1))) throw new StackAssertionError(`oldPath and newPath must have the same prefix. Provided: ${oldPath} and ${newPath}`);
  for (let i = 0; i < oldKeyParts.length; i++) {
    const pathPrefix = oldKeyParts.slice(0, i).join(".");
    const oldPathSuffix = oldKeyParts.slice(i).join(".");
    const newPathSuffix = newKeyParts.slice(i).join(".");
    if (has(obj, pathPrefix) && isObjectLike(get(obj, pathPrefix))) {
      set(obj, pathPrefix, renameProperty(get(obj, pathPrefix), oldPathSuffix, newPathSuffix));
    }
  }
  if (has(obj, oldPath)) {
    set(obj, newPath, get(obj, oldPath));
    deleteKey(obj, oldPath);
  }
  return obj;
}
var projectConfigDefaults = {
  sourceOfTruth: {
    type: "hosted",
    connectionStrings: void 0,
    connectionString: void 0
  }
};
var branchConfigDefaults = {};
var environmentConfigDefaults = {};
var organizationConfigDefaults = {
  rbac: {
    permissions: (key) => ({
      containedPermissionIds: (key2) => void 0,
      description: void 0,
      scope: void 0
    }),
    defaultPermissions: {
      teamCreator: (key) => void 0,
      teamMember: (key) => void 0,
      signUp: (key) => void 0
    }
  },
  apiKeys: {
    enabled: {
      team: false,
      user: false
    }
  },
  teams: {
    createPersonalTeamOnSignUp: false,
    allowClientTeamCreation: false
  },
  users: {
    allowClientUserDeletion: false
  },
  domains: {
    allowLocalhost: false,
    trustedDomains: (key) => ({
      baseUrl: void 0,
      handlerPath: "/handler"
    })
  },
  auth: {
    allowSignUp: true,
    password: {
      allowSignIn: false
    },
    otp: {
      allowSignIn: false
    },
    passkey: {
      allowSignIn: false
    },
    oauth: {
      accountMergeStrategy: "link_method",
      providers: (key) => ({
        type: void 0,
        isShared: true,
        allowSignIn: false,
        allowConnectedAccounts: false,
        clientId: void 0,
        clientSecret: void 0,
        facebookConfigId: void 0,
        microsoftTenantId: void 0
      })
    }
  },
  emails: {
    server: {
      isShared: true,
      provider: "smtp",
      host: void 0,
      port: void 0,
      username: void 0,
      password: void 0,
      senderName: void 0,
      senderEmail: void 0
    },
    selectedThemeId: DEFAULT_EMAIL_THEME_ID,
    themes: typedAssign((key) => ({
      displayName: "Unnamed Theme",
      tsxSource: "Error: Theme config is missing TypeScript source code."
    }), DEFAULT_EMAIL_THEMES),
    templates: typedAssign((key) => ({
      displayName: "Unnamed Template",
      tsxSource: "Error: Template config is missing TypeScript source code.",
      themeId: void 0
    }), DEFAULT_EMAIL_TEMPLATES)
  },
  payments: {
    autoPay: void 0,
    groups: (key) => ({
      displayName: void 0
    }),
    offers: (key) => ({
      displayName: key,
      groupId: void 0,
      customerType: "user",
      freeTrial: void 0,
      serverOnly: false,
      stackable: void 0,
      isAddOnTo: false,
      prices: (key2) => ({
        ...typedFromEntries(SUPPORTED_CURRENCIES.map((currency) => [currency.code, void 0])),
        interval: void 0,
        serverOnly: false,
        freeTrial: void 0
      }),
      includedItems: (key2) => ({
        quantity: 0,
        repeat: "never",
        expires: "when-repeated"
      })
    }),
    items: (key) => ({
      displayName: key,
      customerType: "user"
    })
  },
  dataVault: {
    stores: (key) => ({
      displayName: "Unnamed Vault"
    })
  },
  workflows: {
    availableWorkflows: (key) => ({
      displayName: "Unnamed Workflow",
      tsSource: "Error: Workflow config is missing TypeScript source code.",
      enabled: false
    })
  }
};
typeAssertIs()();
typeAssertIs()();
function deepReplaceFunctionsWithObjects(obj) {
  return mapValues({ ...obj }, (v) => isObjectLike(v) ? deepReplaceFunctionsWithObjects(v) : v);
}
function applyDefaults(defaults, config) {
  const res = deepReplaceFunctionsWithObjects(defaults);
  outer: for (const [key, mergeValue] of Object.entries(config)) {
    if (mergeValue === void 0) continue;
    const keyParts = key.split(".");
    let baseValue = defaults;
    let currentRes = res;
    for (const [index, part] of keyParts.entries()) {
      baseValue = has(baseValue, part) ? get(baseValue, part) : typeof baseValue === "function" ? baseValue(part) : void 0;
      if (baseValue === void 0 || !isObjectLike(baseValue)) {
        set(res, key, mergeValue);
        continue outer;
      }
      if (!has(currentRes, part)) set(currentRes, part, deepReplaceFunctionsWithObjects(baseValue));
      currentRes = get(currentRes, part);
    }
    set(res, key, isObjectLike(mergeValue) ? applyDefaults(baseValue, mergeValue) : mergeValue);
  }
  return res;
}
function applyProjectDefaults(config) {
  return applyDefaults(projectConfigDefaults, config);
}
function applyBranchDefaults(config) {
  return applyDefaults(
    branchConfigDefaults,
    applyDefaults(
      projectConfigDefaults,
      config
    )
  );
}
function applyEnvironmentDefaults(config) {
  return applyDefaults(
    environmentConfigDefaults,
    applyDefaults(
      branchConfigDefaults,
      applyDefaults(
        projectConfigDefaults,
        config
      )
    )
  );
}
function applyOrganizationDefaults(config) {
  return applyDefaults(
    organizationConfigDefaults,
    applyDefaults(
      environmentConfigDefaults,
      applyDefaults(
        branchConfigDefaults,
        applyDefaults(
          projectConfigDefaults,
          config
        )
      )
    )
  );
}
async function sanitizeProjectConfig(config) {
  assertNormalized(config);
  const oldSourceOfTruth = config.sourceOfTruth;
  const sourceOfTruth = oldSourceOfTruth.type === "neon" && typeof oldSourceOfTruth.connectionStrings === "object" ? {
    type: "neon",
    connectionStrings: { ...filterUndefined(oldSourceOfTruth.connectionStrings) }
  } : oldSourceOfTruth.type === "postgres" && typeof oldSourceOfTruth.connectionString === "string" ? {
    type: "postgres",
    connectionString: oldSourceOfTruth.connectionString
  } : {
    type: "hosted"
  };
  return {
    ...config,
    sourceOfTruth
  };
}
async function sanitizeBranchConfig(config) {
  assertNormalized(config);
  const prepared = await sanitizeProjectConfig(config);
  return {
    ...prepared
  };
}
async function sanitizeEnvironmentConfig(config) {
  assertNormalized(config);
  const prepared = await sanitizeBranchConfig(config);
  return {
    ...prepared
  };
}
async function sanitizeOrganizationConfig(config) {
  assertNormalized(config);
  const prepared = await sanitizeEnvironmentConfig(config);
  const themes = {
    ...DEFAULT_EMAIL_THEMES,
    ...prepared.emails.themes
  };
  const templates = {
    ...DEFAULT_EMAIL_TEMPLATES,
    ...prepared.emails.templates
  };
  const offers = typedFromEntries(typedEntries(prepared.payments.offers).map(([key, offer]) => {
    const isAddOnTo = offer.isAddOnTo === false ? false : typedFromEntries(Object.keys(offer.isAddOnTo).map((key2) => [key2, true]));
    const prices = offer.prices === "include-by-default" ? "include-by-default" : typedFromEntries(typedEntries(offer.prices).map(([key2, value]) => {
      const data = { serverOnly: false, ...value ?? {} };
      return [key2, data];
    }));
    return [key, {
      ...offer,
      isAddOnTo,
      prices
    }];
  }));
  return {
    ...prepared,
    emails: {
      ...prepared.emails,
      selectedThemeId: has(themes, prepared.emails.selectedThemeId) ? prepared.emails.selectedThemeId : DEFAULT_EMAIL_THEME_ID,
      themes,
      templates
    },
    payments: {
      ...prepared.payments,
      offers
    }
  };
}
async function getConfigOverrideErrors(schema, configOverride, options = {}) {
  if (typeof configOverride !== "object" || configOverride === null) {
    return Result.error("Config override must be a non-null object.");
  }
  if (Object.getPrototypeOf(configOverride) !== Object.getPrototypeOf({})) {
    return Result.error("Config override must be plain old JavaScript object.");
  }
  const reason = getInvalidConfigReason(configOverride, { configName: "override" });
  if (reason) return Result.error("Invalid config format: " + reason);
  const getSubSchema = (schema2, key) => {
    const keyParts = key.split(".");
    if (!schema2.hasNested(keyParts[0])) {
      return void 0;
    }
    const nestedSchema = schema2.getNested(keyParts[0]);
    if (nestedSchema.meta()?.stackConfigCanNoLongerBeOverridden && !options.allowPropertiesThatCanNoLongerBeOverridden) {
      return void 0;
    }
    if (keyParts.length === 1) {
      return nestedSchema;
    } else {
      return getSubSchema(nestedSchema, keyParts.slice(1).join("."));
    }
  };
  const getRestrictedSchemaBase = (path, schema2) => {
    const schemaInfo = schema2.meta()?.stackSchemaInfo;
    switch (schemaInfo?.type) {
      case "string": {
        const stringSchema = schema2;
        const description = stringSchema.describe();
        let res = yupString();
        if (description.tests.some((t) => t.name === "uuid")) {
          res = res.uuid();
        }
        return res;
      }
      case "number": {
        return yupNumber();
      }
      case "boolean": {
        return yupBoolean();
      }
      case "date": {
        return yupDate();
      }
      case "mixed": {
        return yupMixed();
      }
      case "array": {
        throw new StackAssertionError(`Arrays are not supported in config JSON files (besides tuples). Use a record instead.`, { schemaInfo, schema: schema2 });
      }
      case "tuple": {
        return yupTuple(schemaInfo.items.map((s, index) => getRestrictedSchema(path + `[${index}]`, s)));
      }
      case "union": {
        const schemas = schemaInfo.items;
        const nonObjectSchemas = [...schemas.entries()].filter(([index, s]) => s.meta()?.stackSchemaInfo?.type !== "object");
        const objectSchemas = schemas.filter((s) => s.meta()?.stackSchemaInfo?.type === "object");
        const allObjectSchemaKeys = [...new Set(objectSchemas.flatMap((s) => Object.keys(s.fields)))];
        const mergedObjectSchema = yupObject(
          Object.fromEntries(
            allObjectSchemaKeys.map((key) => [key, yupUnion(
              ...objectSchemas.flatMap((s, index) => s.hasNested(key) ? [s.getNested(key)] : [])
            )])
          )
        );
        return yupUnion(
          ...nonObjectSchemas.map(([index, s]) => getRestrictedSchema(path + `|variant-${index}|`, s)),
          ...objectSchemas.length > 0 ? [getRestrictedSchema(path + (nonObjectSchemas.length > 0 ? `|variant|` : ""), mergedObjectSchema)] : []
        );
      }
      case "record": {
        return yupRecord(getRestrictedSchema(path + ".key", schemaInfo.keySchema), getRestrictedSchema(path + ".value", schemaInfo.valueSchema));
      }
      case "object": {
        const objectSchema = schema2;
        return yupObject(
          Object.fromEntries(
            Object.entries(objectSchema.fields).map(([key, value]) => [key, getRestrictedSchema(path + "." + key, value)])
          )
        );
      }
      case "never": {
        return yupNever();
      }
      default: {
        throw new StackAssertionError(`Unknown schema info at path ${path}: ${JSON.stringify(schemaInfo)}`, { schemaInfo, schema: schema2 });
      }
    }
  };
  const getRestrictedSchema = (path, schema2) => {
    let restricted = getRestrictedSchemaBase(path, schema2);
    restricted = restricted.nullable();
    const description = schema2.describe();
    if (description.oneOf.length > 0) {
      restricted = restricted.oneOf(description.oneOf);
    }
    if (description.notOneOf.length > 0) {
      restricted = restricted.notOneOf(description.notOneOf);
    }
    return restricted;
  };
  for (const [key, value] of Object.entries(configOverride)) {
    if (value === void 0) continue;
    const subSchema = getSubSchema(schema, key);
    if (!subSchema) {
      return Result.error(`The key ${JSON.stringify(key)} is not valid for the schema.`);
    }
    let restrictedSchema = getRestrictedSchema(key, subSchema);
    try {
      await restrictedSchema.validate(value, {
        strict: true,
        ...{
          // Although `path` is not part of the yup types, it is actually recognized and does the correct thing
          path: key
        },
        context: {
          noUnknownPathPrefixes: [""]
        }
      });
    } catch (error) {
      if (error instanceof yup.ValidationError) {
        return Result.error(error.message);
      }
      throw error;
    }
  }
  return Result.ok(null);
}
async function assertNoConfigOverrideErrors(schema, config, options = {}) {
  const res = await getConfigOverrideErrors(schema, config, options);
  if (res.status === "error") throw new StackAssertionError(`Config override is invalid \u2014 at a place where it should have already been validated! ${res.error}`, { options, config });
}
typeAssertIs()();
typeAssertExtends()();
typeAssertExtends()();
async function getIncompleteConfigWarnings(schema, incompleteConfig) {
  await assertNoConfigOverrideErrors(schema, incompleteConfig, { allowPropertiesThatCanNoLongerBeOverridden: true });
  let normalized;
  try {
    normalized = normalize(incompleteConfig, { onDotIntoNull: "empty-object" });
  } catch (error) {
    if (error instanceof NormalizationError) {
      return Result.error(`Config is not normalizable. ` + error.message);
    }
    throw error;
  }
  try {
    await schema.validate(normalized, {
      strict: true,
      context: {
        noUnknownPathPrefixes: [""]
      }
    });
    return Result.ok(null);
  } catch (error) {
    if (error instanceof yup.ValidationError) {
      return Result.error(error.message);
    }
    throw error;
  }
}
typeAssertExtends()();
typeAssertExtends()();
typeAssertExtends()();
typeAssertExtends()();
typeAssert()();
typeAssert()();
typeAssertExtends()();
export {
  applyBranchDefaults,
  applyEnvironmentDefaults,
  applyOrganizationDefaults,
  applyProjectDefaults,
  assertNoConfigOverrideErrors,
  branchConfigSchema,
  branchPaymentsSchema,
  configLevels,
  environmentConfigSchema,
  getConfigOverrideErrors,
  getIncompleteConfigWarnings,
  migrateConfigOverride,
  organizationConfigSchema,
  projectConfigSchema,
  sanitizeBranchConfig,
  sanitizeEnvironmentConfig,
  sanitizeOrganizationConfig,
  sanitizeProjectConfig
};
//# sourceMappingURL=schema.js.map