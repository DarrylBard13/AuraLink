{"version":3,"sources":["../../../src/utils/featurebase.tsx"],"sourcesContent":["import { getEnvVariable } from \"./env\";\nimport { StackAssertionError } from \"./errors\";\n\nexport type FeaturebaseUser = {\n  userId: string,\n  email: string,\n  name?: string,\n  profilePicture?: string,\n};\n\nexport type StackAuthUser = {\n  id: string,\n  primaryEmail: string | null,\n  displayName?: string | null,\n  profileImageUrl?: string | null,\n};\n\n/**\n * Find a Featurebase user by their Stack Auth user ID\n */\nasync function findFeaturebaseUserById(stackAuthUserId: string, apiKey: string): Promise<FeaturebaseUser | null> {\n  try {\n    const response = await fetch(`https://do.featurebase.app/v2/organization/identifyUser?id=${stackAuthUserId}`, {\n      method: 'GET',\n      headers: {\n        'X-API-Key': apiKey,\n      },\n    });\n\n    if (response.status === 404) {\n      return null;\n    }\n\n    if (!response.ok) {\n      throw new StackAssertionError(`Failed to find Featurebase user by ID: ${response.statusText}`);\n    }\n\n    const data = await response.json();\n    const user = data.user;\n\n    if (!user) {\n      throw new StackAssertionError(`Featurebase API returned success but no user data for ID: ${stackAuthUserId}`, { data });\n    }\n\n    return {\n      userId: user.externalUserId || user.userId || stackAuthUserId,\n      email: user.email,\n      name: user.name,\n      profilePicture: user.profilePicture,\n    };\n  } catch (error) {\n    if (error instanceof StackAssertionError) {\n      throw error;\n    }\n    throw new StackAssertionError(\"Failed to find Featurebase user by ID\", { cause: error });\n  }\n}\n\n/**\n * Find a Featurebase user by their email address\n */\nasync function findFeaturebaseUserByEmail(email: string, apiKey: string): Promise<FeaturebaseUser | null> {\n  try {\n    const response = await fetch(`https://do.featurebase.app/v2/organization/identifyUser?email=${encodeURIComponent(email)}`, {\n      method: 'GET',\n      headers: {\n        'X-API-Key': apiKey,\n      },\n    });\n\n    if (response.status === 404) {\n      return null;\n    }\n\n    if (!response.ok) {\n      throw new StackAssertionError(`Failed to find Featurebase user by email: ${response.statusText}`);\n    }\n\n    const data = await response.json();\n    const user = data.user;\n\n    if (!user) {\n      throw new StackAssertionError(`Featurebase API returned success but no user data for email: ${email}`, { data });\n    }\n\n    return {\n      userId: user.externalUserId || user.userId,\n      email: user.email,\n      name: user.name,\n      profilePicture: user.profilePicture,\n    };\n  } catch (error) {\n    console.error('Error finding Featurebase user by email:', error);\n    return null;\n  }\n}\n\n/**\n * Create a new Featurebase user using the identifyUser endpoint\n */\nasync function createFeaturebaseUser(user: FeaturebaseUser, apiKey: string): Promise<FeaturebaseUser> {\n  try {\n    const response = await fetch('https://do.featurebase.app/v2/organization/identifyUser', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-API-Key': apiKey,\n      },\n      body: JSON.stringify({\n        userId: user.userId,\n        email: user.email,\n        name: user.name,\n        profilePicture: user.profilePicture,\n      }),\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => ({}));\n      throw new StackAssertionError(`Failed to create Featurebase user: ${errorData.error || response.statusText}`, { errorData });\n    }\n\n    // The identifyUser endpoint just returns { \"success\": true }, so we return the input data\n    return user;\n  } catch (error) {\n    if (error instanceof StackAssertionError) {\n      throw error;\n    }\n    throw new StackAssertionError(\"Failed to create Featurebase user\", { cause: error });\n\n  }\n}\n\n/**\n * Update an existing Featurebase user (excluding email)\n */\nasync function updateFeaturebaseUser(userId: string, updates: Partial<Omit<FeaturebaseUser, 'userId' | 'email'>>, apiKey: string): Promise<FeaturebaseUser> {\n  try {\n    const response = await fetch(`https://do.featurebase.app/v2/users/${userId}`, {\n      method: 'PATCH',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-API-Key': apiKey,\n      },\n      body: JSON.stringify(updates),\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => ({}));\n      throw new StackAssertionError(`Failed to update Featurebase user: ${errorData.error || response.statusText}`, { errorData });\n    }\n\n    const data = await response.json();\n    return {\n      userId: data.userId || userId,\n      email: data.email,\n      name: data.name,\n      profilePicture: data.profilePicture,\n    };\n  } catch (error) {\n    if (error instanceof StackAssertionError) {\n      throw error;\n    }\n    throw new StackAssertionError(\"Failed to update Featurebase user\", { cause: error });\n  }\n}\n\n/**\n * Get or create a Featurebase user based on Stack Auth user data.\n * This function ensures that:\n * 1. We never change a user's email address on Featurebase\n * 2. We use Stack Auth user ID as the primary identifier\n * 3. We handle email conflicts by using fallback emails\n * 4. We update profile information when needed\n */\nexport async function getOrCreateFeaturebaseUser(\n  stackAuthUser: StackAuthUser,\n  options?: { apiKey?: string }\n): Promise<{ userId: string, email: string }> {\n  const apiKey = options?.apiKey || getEnvVariable(\"STACK_FEATUREBASE_API_KEY\");\n  const fallbackEmail = `${stackAuthUser.id}@featurebase-user.stack-auth-app.com`;\n\n  // First, try to find existing user by Stack Auth user ID\n  const existingById = await findFeaturebaseUserById(stackAuthUser.id, apiKey);\n  if (existingById) {\n    // Ensure the user has an email on Featurebase.\n    let ensuredEmail = existingById.email;\n    if (!ensuredEmail) {\n      try {\n        await createFeaturebaseUser({\n          userId: existingById.userId,\n          email: fallbackEmail,\n          name: stackAuthUser.displayName || undefined,\n          profilePicture: stackAuthUser.profileImageUrl || undefined,\n        }, apiKey);\n        ensuredEmail = fallbackEmail;\n      } catch (e) {\n        // If setting fallback email failed, keep ensuredEmail as-is (undefined) and let callers handle\n        throw new StackAssertionError(`Failed to set fallback email for existing Featurebase user ${existingById.userId}`, { cause: e });\n      }\n    }\n\n    // Update profile information if needed (but not email)\n    try {\n      const updates: Partial<Omit<FeaturebaseUser, 'userId' | 'email'>> = {};\n\n      if (stackAuthUser.displayName && stackAuthUser.displayName !== existingById.name) {\n        updates.name = stackAuthUser.displayName;\n      }\n\n      if (stackAuthUser.profileImageUrl && stackAuthUser.profileImageUrl !== existingById.profilePicture) {\n        updates.profilePicture = stackAuthUser.profileImageUrl;\n      }\n\n      if (Object.keys(updates).length > 0) {\n        await updateFeaturebaseUser(existingById.userId, updates, apiKey);\n      }\n    } catch (error) {\n      console.error('Failed to update existing Featurebase user profile:', error);\n      // Continue with existing user data even if update fails\n    }\n\n    return {\n      userId: existingById.userId,\n      email: ensuredEmail,\n    };\n  }\n\n  // No existing user found by ID, need to create one\n  const candidateEmail = stackAuthUser.primaryEmail ?? fallbackEmail;\n\n  // Check if someone already has this email on Featurebase\n  const existingByEmail = await findFeaturebaseUserByEmail(candidateEmail, apiKey);\n  const safeEmail = existingByEmail ? fallbackEmail : candidateEmail;\n\n  // Create new user\n  const created = await createFeaturebaseUser({\n    userId: stackAuthUser.id,\n    email: safeEmail,\n    name: stackAuthUser.displayName || stackAuthUser.primaryEmail?.split('@')[0] || 'User',\n    profilePicture: stackAuthUser.profileImageUrl || undefined,\n  }, apiKey);\n\n  return {\n    userId: created.userId,\n    email: created.email,\n  };\n}\n"],"mappings":"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","names":[]}