"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/helpers/vault/server-side.ts
var server_side_exports = {};
__export(server_side_exports, {
  decryptWithKms: () => decryptWithKms,
  encryptWithKms: () => encryptWithKms
});
module.exports = __toCommonJS(server_side_exports);
var import_client_kms = require("@aws-sdk/client-kms");
var import_oidc = require("@vercel/functions/oidc");
var import_bytes = require("../../utils/bytes.js");
var import_crypto = require("../../utils/crypto.js");
var import_env = require("../../utils/env.js");
var import_results = require("../../utils/results.js");
function getKmsClient() {
  const roleArn = (0, import_env.getEnvVariable)("STACK_AWS_VERCEL_OIDC_ROLE_ARN", "");
  return new import_client_kms.KMSClient({
    region: (0, import_env.getEnvVariable)("STACK_AWS_REGION"),
    endpoint: (0, import_env.getEnvVariable)("STACK_AWS_KMS_ENDPOINT"),
    credentials: roleArn ? (0, import_oidc.awsCredentialsProvider)({
      roleArn
    }) : {
      accessKeyId: (0, import_env.getEnvVariable)("STACK_AWS_ACCESS_KEY_ID"),
      secretAccessKey: (0, import_env.getEnvVariable)("STACK_AWS_SECRET_ACCESS_KEY")
    }
  });
}
async function getOrCreateKekId() {
  const id = "alias/stack-data-vault-server-side-kek";
  const kms = getKmsClient();
  try {
    const describeResult = await kms.send(new import_client_kms.DescribeKeyCommand({ KeyId: id }));
    if (describeResult.KeyMetadata?.KeyId) return describeResult.KeyMetadata.KeyId;
  } catch (e) {
    if (e instanceof Error && e.name !== "NotFoundException") {
      throw e;
    }
  }
  const { KeyMetadata } = await kms.send(new import_client_kms.CreateKeyCommand({
    KeyUsage: "ENCRYPT_DECRYPT",
    Description: "DataVault KEK"
  }));
  await kms.send(new import_client_kms.CreateAliasCommand({ AliasName: id, TargetKeyId: KeyMetadata.KeyId }));
  return id;
}
async function genDEK() {
  const kekId = await getOrCreateKekId();
  const kms = getKmsClient();
  const out = await kms.send(new import_client_kms.GenerateDataKeyCommand({ KeyId: kekId, KeySpec: "AES_256" }));
  if (!out.Plaintext || !out.CiphertextBlob) throw new Error("GenerateDataKey failed");
  return {
    dekBytes: out.Plaintext,
    edkBytes: out.CiphertextBlob
  };
}
async function unwrapDEK(edk_b64) {
  const edkBytes = (0, import_bytes.decodeBase64)(edk_b64);
  const kms = getKmsClient();
  const out = await kms.send(new import_client_kms.DecryptCommand({ CiphertextBlob: edkBytes }));
  if (!out.Plaintext) throw new Error("KMS Decrypt failed");
  return {
    dekBytes: out.Plaintext,
    edkBytes
  };
}
async function encryptWithKms(value) {
  const { dekBytes, edkBytes } = await genDEK();
  try {
    const ciphertext = await (0, import_crypto.encrypt)({
      purpose: "stack-data-vault-server-side-encryption",
      secret: dekBytes,
      value: new TextEncoder().encode(value)
    });
    return { edkBase64: (0, import_bytes.encodeBase64)(edkBytes), ciphertextBase64: (0, import_bytes.encodeBase64)(ciphertext) };
  } finally {
    dekBytes.fill(0);
  }
}
async function decryptWithKms(encrypted) {
  const { dekBytes } = await unwrapDEK(encrypted.edkBase64);
  try {
    const value = import_results.Result.orThrow(await (0, import_crypto.decrypt)({
      purpose: "stack-data-vault-server-side-encryption",
      secret: dekBytes,
      cipher: (0, import_bytes.decodeBase64)(encrypted.ciphertextBase64)
    }));
    return new TextDecoder().decode(value);
  } finally {
    dekBytes.fill(0);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  decryptWithKms,
  encryptWithKms
});
//# sourceMappingURL=server-side.js.map