"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/hooks/use-hover.tsx
var use_hover_exports = {};
__export(use_hover_exports, {
  useHover: () => useHover
});
module.exports = __toCommonJS(use_hover_exports);
var import_react = require("react");
var import_react2 = require("../utils/react.js");
function useHover(ref, options = {}) {
  const counter = (0, import_react2.useRefState)(0);
  (0, import_react.useLayoutEffect)(() => {
    const el = ref.current;
    if (!el) return;
    let incr = 0;
    let prevInside = false;
    const contains = (r, x, y) => x >= r.left && x <= r.right && y >= r.top && y <= r.bottom;
    const enter = () => {
      incr++;
      counter.set((c) => c + 1);
      if (counter.current === 1) {
        options.onMouseEnter?.();
      }
    };
    const leave = () => {
      incr--;
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          counter.set((c) => c - 1);
          if (counter.current === 0) {
            options.onMouseLeave?.();
          }
        });
      });
    };
    const topMatchesTarget = (x, y) => {
      const top = document.elementFromPoint(x, y);
      return !!(top && (top === el || el.contains(top)));
    };
    const processPoint = (x, y) => {
      const rect = el.getBoundingClientRect();
      const inside = contains(rect, x, y) && topMatchesTarget(x, y);
      if (inside && !prevInside) {
        enter();
      } else if (!inside && prevInside) {
        leave();
      }
      prevInside = inside;
    };
    const onMove = (e) => {
      if (e.pointerType !== "mouse") return;
      const batch = e.getCoalescedEvents();
      if (batch.length) {
        for (let eventIndex = 0; eventIndex < batch.length - 1; eventIndex++) {
          const e1 = batch[eventIndex];
          const e2 = batch[eventIndex + 1];
          const steps = 10;
          for (let i = 0; i <= steps; i++) {
            processPoint(e1.clientX + (e2.clientX - e1.clientX) * i / steps, e1.clientY + (e2.clientY - e1.clientY) * i / steps);
          }
        }
      } else {
        processPoint(e.clientX, e.clientY);
      }
    };
    window.addEventListener("pointermove", onMove, { passive: true });
    return () => {
      window.removeEventListener("pointermove", onMove);
      counter.set((c) => c - incr);
    };
  }, []);
  return counter.current > 0;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  useHover
});
//# sourceMappingURL=use-hover.js.map