import { OptionalKeys, RequiredKeys } from '../utils/types.js';
import '../utils/strings.js';

type ConfigValue = string | number | boolean | null | ConfigValue[] | Config;
type Config = {
    [keyOrDotNotation: string]: ConfigValue | undefined;
};
type NormalizedConfigValue = string | number | boolean | NormalizedConfig | NormalizedConfigValue[];
type NormalizedConfig = {
    [key: string]: NormalizedConfigValue | undefined;
};
type _NormalizesTo<N> = N extends object ? (Config & {
    [K in OptionalKeys<N>]?: _NormalizesTo<N[K]> | null;
} & {
    [K in RequiredKeys<N>]: undefined extends N[K] ? _NormalizesTo<N[K]> | null : _NormalizesTo<N[K]>;
} & {
    [K in `${string}.${string}`]: ConfigValue;
}) : N;
type NormalizesTo<N extends NormalizedConfig> = _NormalizesTo<N>;
/**
 * Note that a config can both be valid and not normalizable.
 */
declare function isValidConfig(c: unknown): c is Config;
declare function getInvalidConfigReason(c: unknown, options?: {
    configName?: string;
}): string | undefined;
declare function assertValidConfig(c: unknown): void;
declare function override(c1: Config, ...configs: Config[]): Config;
type NormalizeOptions = {
    /**
     * What to do if a dot notation is used on a value that is not an object.
     *
     * - "throw" (default): Throw an error.
     * - "ignore": Ignore the dot notation field.
     */
    onDotIntoNonObject?: "throw" | "ignore";
    /**
     * What to do if a dot notation is used on a value that is null.
     *
     * - "like-non-object"  (default): Treat it like a non-object. See `onDotIntoNonObject`.
     * - "throw": Throw an error.
     * - "ignore": Ignore the dot notation field.
     * - "empty-object": Set the value to an empty object.
     */
    onDotIntoNull?: "like-non-object" | "throw" | "ignore" | "empty-object";
};
declare class NormalizationError extends Error {
    constructor(...args: ConstructorParameters<typeof Error>);
}
declare function isNormalized(c: Config): c is NormalizedConfig;
declare function assertNormalized(c: Config): asserts c is NormalizedConfig;
declare function normalize(c: Config, options?: NormalizeOptions): NormalizedConfig;

export { type Config, type ConfigValue, NormalizationError, type NormalizedConfig, type NormalizedConfigValue, type NormalizesTo, type _NormalizesTo, assertNormalized, assertValidConfig, getInvalidConfigReason, isNormalized, isValidConfig, normalize, override };
